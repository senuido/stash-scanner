lets start with some examples:
this filter will match disfavour sold at or under 2.5ex:
{
	"title": "Cheap Atziri's Disfavour",
	"criteria": {
		"name": ["atziri's disfavour"],
		"buyout": true,
		"price": "2.5 ex"
	}
}

this filter will find i84 crystal belts for crafting with max price of 6ex:
{
	"title": "Crystal Belt i84",
	"id": "crystal-i84",
	"criteria": {
		"base": "crystal belt",
		"ilvl": 84,
		"type": ["normal", "magic", "rare"],
		"buyout": true,
		"price": "6 exalted",
		"corrupted": false
	}
}

using the id and baseId keywords we can reuse other filters.
for example, this filter will use the previous filter to find corrupted i84 crystal belts at 1/5 of the price:
{
	"title": "Corrupted Crystal Belt i84",
	"baseId": "Crystal-i84",
	"criteria": {
		"corrupted": true,
		"price": " / 5"
	}
}


filter options are:
title 		- a displayable name for the filter. mandatory.
id			- unique name to be used with baseId by other filters for inheritance
baseId 		- id of the filter to inherit from (if theres an overlap, the base is overriden)
enabled		- specifies if the filter should be active
description	- text description for the filter


criteria options:
base			- item base type. for example: 'crystal belt'
ilvl			- minimum item level
corrupted		- specifies if item is corrupted
unmodifiable	- specifies if item cannot be modified (mirrored or corrupted)
crafted			- specifies if item has crafted mods
buyout		 	- specifies if item has a buyout price
sockets		 	- minimum number of sockets
links			- minimum number of links
stacksize	 	- minimum stack size. useful for finding big stacks of essences/cards in essence/div tabs. note this won't work well for items outside div/essence tabs because the max stack size is a lot lower
modcount_min 	- minimum number of implicit+explicit mods. note this isn't very reliable because 'hybrid' mods might be considered as two mods. mostly useful for finding 4 mod jewels
modcount_max 	- same as above but maximum number of mods

name			- list of item names. for example: ['The Fiend', 'The Doctor']
type			- list of item types. for example: ['normal', 'rare', 'magic']. valid values are 'normal', 'magic', 'rare', 'unique', 'gem', 'currency', 'divination card', 'quest item', 'prophecy', 'relic'
price			- maximum item price. structure is '<amount> <currency>'. for example: '100 chaos' or '2 exalted' or '2 ex'
				  if baseId is specified you can use the operators '/','*','+','-' to modify the base price. for example: '+1 ex' or '* 3' or '/ 2'

quality			- minimum item quality
level			- minimum level
level_max		- maximum level
exp				- minimum gem experience percentage
				  
fres			- minimum total fire resistance
cres			- minimum total cold resistance
lres			- minimum total lightning resistance
chres			- minimum chaos resistance
ele_res			- minimum total elemental resistances
total_res		- minimum total resistances

dps 			- minimum dps
pdps 			- minimum physical dps
edps			- minimum elemental dps

armour			- minimum potential (quality 20 if modifiable) armour
evasion			- minimum potential evasion
es				- minimum potential energy shield
total_life		- minimum total life

mods - matches expressions to filter item mods. inner structure:
{
	'match_min': minimum number of matches
	'match_max': maximum number of matches
	'mods': [
		{
			'expr': regular expression to match in item mods. mandatory.
			'values' list of values to be compared with values captured from expression.
			'required': specifies if this must be matched. only relevant if you specified match_min or match_max
		}
	]
}

implicit - same as mods but only for implicit mods
explicit - same as mods but only for explicit mods

if values is empty then only expr is matched.
for example, if we're looking for sadima's with 22+ IIQ you could write this:

"explicit": 
{
	"mods": [
		"expr": "2[2-4]% increased Quantity of Items found"
	]
}

if values has one value, then the value is the minimum average of the captured values
for example, when looking for a vinktar with high damage to spells and low charges used, you could write:

"explicit": 
{
	"mods": [
		{
			"expr": "Adds ([0-9]+) to ([0-9]+) Lightning Damage to Spells during Flask effect",
			"values": [ 55 ]
		},
		{
			"expr": "8[0-5]% increased Charges used"
		}
	]
}

if values has more than one value, then each value is minimum for the respective captured value
for example, when looking for atziri's disfavour with 225+ to 275+ damage, you could write:

"explicit": 
{
	"mods": [
		{
			"expr": "Adds ([0-9]+) to ([0-9]+) Physical Damage",
			"values": [ 225, 275 ]
		}
	]
}